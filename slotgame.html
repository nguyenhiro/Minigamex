<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>MiniGamex Slot</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', Arial, sans-serif;
            background: url('7.png') center/cover no-repeat fixed;
            color: #222;
            text-align: center;
            padding: 30px;
        }
        .container {
            background: rgba(255,255,255,0.93);
            margin: auto;
            padding: 2rem 1.5rem 2.5rem 1.5rem;
            border-radius: 1rem;
            max-width: 420px;
            box-shadow: 0 10px 40px #0003, 0 2px 10px #2a3e4c44;
            position: relative;
        }
        h1 { color: #f59e42; font-size: 2rem; letter-spacing: 2px; text-shadow: 0 2px 8px #0004; }
        .balance-blk { margin: 0 0 18px 0; font-size:1.12rem; }
        .balance-blk span { color: #10B981; font-weight: bold; }
        #connectWalletBtn, #depositBtn {
            font-size: 1rem; font-weight: bold;
            padding: 0.55rem 1.2rem; border: none; border-radius: 7px;
            margin: 0 5px 12px 5px;
        }
        #connectWalletBtn[disabled], #depositBtn[disabled] { background: #ccc; color: #666; cursor: not-allowed; }
        #connectWalletBtn { background: #6366f1; color: #fff; }
        #connectWalletBtn.connected { background: #10B981 !important; color: #fff !important; }
        #depositBtn { background: #f59e42; color: #000; }
        .bet-amount-group { display: flex; justify-content: center; gap: 10px; margin: 18px 0; flex-wrap: wrap; }
        .bet-amount-btn, #startGameBtn {
            padding: 12px 18px; border: none; border-radius: 7px; font-size: 1rem; font-weight: bold;
            cursor: pointer; background: #4caf50; color: #fff; margin-bottom: 3px; min-width: 60px;
            transition: background 0.18s, transform 0.12s;
        }
        .bet-amount-btn.selected { background: #f59e42; color: #222; }
        .bet-amount-btn:active, #startGameBtn:active { transform: scale(0.93);}
        #startGameBtn { margin: 14px 0 10px 0; background: #10B981; }
        #startGameBtn:disabled { background: #9ca3af !important; }
        .info-blk {
            margin: 10px 0 0 0;
            font-size: 1.03rem;
            color: #334155;
        }
        #timerDisplay {
            color: #f59e42;
            font-weight: bold;
            margin: 0 0 12px 0;
            font-size: 1.15rem;
            min-height: 28px;
            letter-spacing: 1px;
        }
        .slot-machine {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 120px;
            margin: 20px 0;
            background: #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }
        .reel {
            width: 80px;
            height: 100px; /* Chi·ªÅu cao c·ªßa khung nh√¨n reel */
            border: 2px solid #ccc;
            margin: 0 5px;
            display: flex;
            /* flex-direction: column; Removed, symbol-list handles stacking */
            justify-content: flex-start;
            align-items: center;
            font-size: 3.5rem;
            background: #fff;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.3s ease-out; /* Transition cho hi·ªáu ·ª©ng d·ª´ng m∆∞·ª£t m√† */
        }
        .reel.spinning .symbol-list { /* √Åp d·ª•ng animation cho symbol-list khi reel ƒëang spinning */
            animation: spinReelAnimation 0.1s linear infinite; /* Animation quay nhanh */
        }
        .reel.spinning { /* Reset transition khi ƒëang spinning ƒë·ªÉ kh√¥ng b·ªã ·∫£nh h∆∞·ªüng b·ªüi transition c·ªßa symbol-list khi d·ª´ng */
            transition: none;
        }

        .reel .symbol-list { /* Container cho c√°c bi·ªÉu t∆∞·ª£ng b√™n trong reel */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .reel .symbol-list span {
            height: 100px; /* M·ªói bi·ªÉu t∆∞·ª£ng chi·∫øm chi·ªÅu cao ƒë·∫ßy ƒë·ªß c·ªßa reel */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Keyframes cho hi·ªáu ·ª©ng quay nhanh */
        @keyframes spinReelAnimation {
            0% { transform: translateY(0); }
            100% { transform: translateY(-1000px); } /* ƒêi·ªÅu ch·ªânh gi√° tr·ªã n√†y t√πy theo s·ªë l∆∞·ª£ng symbols v√† REEL_HEIGHT ƒë·ªÉ t·∫°o c·∫£m gi√°c li√™n t·ª•c */
        }

        #slotResult {
            font-size: 1.8rem;
            margin: 10px 0 10px 0;
            min-height: 48px;
            letter-spacing: 1px;
            font-weight: bold;
            color: #333;
        }
        /* Modal */
        .modal-overlay {
            position: fixed; left: 0; top: 0; right: 0; bottom: 0;
            background: rgba(44, 62, 80, 0.32);
            z-index: 1000;
            display: none;
        }
        .modal {
            position: fixed;
            left: 50%; top: 50%; transform: translate(-50%,-50%);
            background: white;
            min-width: 280px;
            max-width: 90vw;
            border-radius: 1rem;
            box-shadow: 0 10px 40px #0003;
            z-index: 1010;
            padding: 2.2rem 1.5rem 1.4rem 1.5rem;
            text-align: center;
            display: none;
            flex-direction: column;
            gap: 1.1rem;
        }
        .modal.show, .modal-overlay.show { display: flex !important; }
        .modal-title { font-size: 1.3rem; font-weight: bold; color: #f59e42; margin-bottom: 0.3rem; }
        .modal-message { font-size: 1.04rem; color: #334155; margin-bottom: 0.7rem; }
        .modal-emoji { font-size: 2.7rem; margin-bottom: 0.2rem; }
        .modal-btns { display: flex; justify-content: center; gap: 1rem; }
        .modal-btns button {
            background: #10B981; color: #fff;
            font-size: 1.08rem; font-weight: bold; border: none; border-radius: 7px;
            padding: 0.55rem 1.3rem; min-width: 110px;
        }
        .modal-btns button.secondary { background: #9ca3af; color: #222; }
        @media (max-width: 500px) {
            .container { padding: 1.2rem 0.5rem 1.5rem 0.5rem; }
            .reel { font-size: 2.2rem; width: 60px; height: 80px; }
            .reel .symbol-list span { height: 80px; }
            /* ƒêi·ªÅu ch·ªânh animation cho k√≠ch th∆∞·ªõc nh·ªè h∆°n n·∫øu c·∫ßn */
            @keyframes spinReelAnimation {
                0% { transform: translateY(0); }
                100% { transform: translateY(-800px); } /* ƒêi·ªÅu ch·ªânh cho height 80px */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Slot Machine</h1>
        <div>
            <button id="connectWalletBtn"><span id="walletBtnIcon">üîó</span> <span id="walletBtnText">K·∫øt n·ªëi v√≠</span></button>
            <button id="depositBtn">üí∞ N·∫°p/R√∫t Xu</button>
        </div>
        <div class="balance-blk">T·ªïng Xu: <span id="currentBalance">0</span></div>
        <div class="info-blk" id="currentBetInfo">C∆∞·ª£c: <span id="displayBetAmount">0</span> Xu</div>
        <span class="bet-input-label">ƒê·∫∑t c∆∞·ª£c:</span>
        <div class="bet-amount-group" id="betAmountGroup">
            <button type="button" class="bet-amount-btn" data-amount="2">2</button>
            <button type="button" class="bet-amount-btn" data-amount="6">6</button>
            <button type="button" class="bet-amount-btn" data-amount="10">10</button>
            <button type="button" class="bet-amount-btn" data-amount="15">15</button>
            <button type="button" class="bet-amount-btn" data-amount="20">20</button>
        </div>
        <button id="startGameBtn">Quay</button>
        <div id="timerDisplay"></div>

        <div class="slot-machine" id="slotMachine">
            <div class="reel" id="reel1"><div class="symbol-list"></div></div>
            <div class="reel" id="reel2"><div class="symbol-list"></div></div>
            <div class="reel" id="reel3"><div class="symbol-list"></div></div>
        </div>
        <div id="slotResult">Nh·∫•n Quay ƒë·ªÉ b·∫Øt ƒë·∫ßu!</div>
    </div>
    <div class="modal-overlay" id="modalOverlay"></div>
    <div class="modal" id="resultModal">
        <div class="modal-title" id="modalTitle"></div>
        <div class="modal-message" id="modalMessage"></div>
        <div class="modal-emoji" id="modalEmoji"></div>
        <div class="modal-btns">
            <button id="playAgainBtn">Ch∆°i L·∫°i</button>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.0/dist/ethers.umd.min.js"></script>
    <script>
    // ======= CONFIG & BACKEND =======
    const BACKEND_URL = "http://localhost:3000";
    let provider, signer, userAddress = null;
    let currentBalance = 0;

    // ======= DOM =======
    const connectWalletBtn = document.getElementById('connectWalletBtn');
    const walletBtnIcon = document.getElementById('walletBtnIcon');
    const walletBtnText = document.getElementById('walletBtnText');
    const depositBtn = document.getElementById('depositBtn');
    const currentBalanceDisplay = document.getElementById('currentBalance');
    const displayBetAmount = document.getElementById('displayBetAmount');
    const currentBetInfo = document.getElementById('currentBetInfo');
    const timerDisplay = document.getElementById('timerDisplay');
    const slotResultDisplay = document.getElementById('slotResult');
    const betAmountBtns = document.querySelectorAll('.bet-amount-btn');
    const spinButton = document.getElementById('startGameBtn');
    const modalOverlay = document.getElementById('modalOverlay');
    const resultModal = document.getElementById('resultModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalMessage = document.getElementById('modalMessage');
    const modalEmoji = document.getElementById('modalEmoji');
    const playAgainBtn = document.getElementById('playAgainBtn');

    // Slot specific DOM elements
    const slotMachine = document.getElementById('slotMachine');
    const reels = [
        document.getElementById('reel1'),
        document.getElementById('reel2'),
        document.getElementById('reel3')
    ];
    const symbolLists = reels.map(reel => reel.querySelector('.symbol-list'));

    // ==== GAME VARS ====
    let currentBetAmount = 2;
    let gameLocked = false;

    // Slot specific game variables
    const symbols = ['üçí', 'üçã', 'üîî', '‚≠ê', 'üçÄ', '7Ô∏è‚É£'];
    const REEL_HEIGHT = 100; // Ph·∫£i kh·ªõp v·ªõi chi·ªÅu cao c·ªßa .reel span trong CSS
    const SPIN_DURATION_BASE = 1000; // Gi·∫£m th·ªùi gian quay c∆° b·∫£n ƒë·ªÉ test nhanh h∆°n
    const SPIN_DURATION_OFFSET = 200; // Gi·∫£m offset ƒë·ªÉ c√°c cu·ªôn d·ª´ng g·∫ßn nhau h∆°n

    // ======= ƒê·ªíNG B·ªò XU =======
    async function refreshBalance() {
        if (!userAddress) {
            currentBalance = 0;
            updateWalletDisplay();
            return;
        }
        try {
            const res = await fetch(`${BACKEND_URL}/balance/${userAddress}`);
            if (res.ok) {
                const data = await res.json();
                currentBalance = data.coins;
            } else currentBalance = 0;
        } catch { currentBalance = 0; }
        updateWalletDisplay();
    }
    function updateWalletDisplay() {
        currentBalanceDisplay.textContent = currentBalance.toLocaleString();
    }
    function updateWalletUI() {
        if (userAddress) {
            connectWalletBtn.disabled = true;
            connectWalletBtn.classList.add('connected');
            walletBtnIcon.textContent = "üü¢";
            walletBtnText.textContent = "ƒê√£ k·∫øt n·ªëi";
        } else {
            connectWalletBtn.disabled = false;
            connectWalletBtn.classList.remove('connected');
            walletBtnIcon.textContent = "üîó";
            walletBtnText.textContent = "K·∫øt n·ªëi v√≠";
        }
    }
    function setControlsBasedOnWallet() {
        const disabled = !userAddress;
        betAmountBtns.forEach(btn => btn.disabled = disabled);
        spinButton.disabled = disabled;
        depositBtn.disabled = disabled;
    }
    depositBtn.addEventListener('click', () => {
        window.location.href = "https://nguyenhiro.github.io/Minigamex/deposit.html?from=xingau";
    });

    // ======= MODAL =======
    function showResultModal(title, message, emoji) {
        modalTitle.textContent = title;
        modalMessage.textContent = message;
        modalEmoji.textContent = emoji || '';
        resultModal.classList.add("show");
        modalOverlay.classList.add("show");
    }
    function hideResultModal() {
        resultModal.classList.remove("show");
        modalOverlay.classList.remove("show");
    }

    // ==== REEL GENERATION ====
    function populateReels() {
        const tempSymbols = [...symbols, ...symbols, ...symbols]; // L·∫∑p l·∫°i symbols v√†i l·∫ßn ƒë·ªÉ cu·ªôn m∆∞·ª£t h∆°n
        symbolLists.forEach(list => {
            list.innerHTML = ''; // Clear existing symbols
            tempSymbols.forEach(symbol => {
                const span = document.createElement('span');
                span.textContent = symbol;
                list.appendChild(span);
            });
        });
    }

    // ====== GAME LOGIC ======
    function initializeGame() {
        currentBetAmount = 2;
        gameLocked = false;
        betAmountBtns.forEach(btn => btn.classList.remove('selected'));
        betAmountBtns.forEach(btn => {
            if (btn.dataset.amount === "2") btn.classList.add('selected');
        });
        spinButton.disabled = !userAddress;
        spinButton.style.display = "inline-block";
        slotResultDisplay.innerHTML = 'Nh·∫•n Quay ƒë·ªÉ b·∫Øt ƒë·∫ßu!';
        timerDisplay.textContent = "";

        populateReels(); // Regenerate symbols on init
        reels.forEach(reel => {
            reel.classList.remove('spinning');
            reel.querySelector('.symbol-list').style.transform = `translateY(0px)`; // Reset position of symbol-list
        });
        updateWalletDisplay();
        updateBetInfo();
        hideResultModal();
        setControlsBasedOnWallet();
    }
    function updateBetInfo() {
        displayBetAmount.textContent = currentBetAmount.toLocaleString();
    }

    async function spinReels() {
        if (!userAddress) { showResultModal("Ch∆∞a k·∫øt n·ªëi v√≠", "Vui l√≤ng k·∫øt n·ªëi v√≠.", "‚ö†Ô∏è"); return; }
        if (currentBetAmount <= 0) { showResultModal("Thi·∫øu c∆∞·ª£c", "Ch·ªçn s·ªë xu ƒë·∫∑t c∆∞·ª£c!", "‚ö†Ô∏è"); return; }
        if (currentBetAmount > currentBalance) { showResultModal("Thi·∫øu xu", "B·∫°n kh√¥ng ƒë·ªß xu!", "üí∏"); return; }
        if (gameLocked) return;
        gameLocked = true;
        spinButton.disabled = true;
        slotResultDisplay.textContent = "ƒêang quay...";
        timerDisplay.textContent = "";

        try {
            // First, deduct the bet
            let betResponse = await fetch(`${BACKEND_URL}/play/bet`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ wallet: userAddress, betAmount: currentBetAmount })
            });
            let betText = await betResponse.text();
            let betData = null;
            try { betData = JSON.parse(betText); } catch(e) {}
            if (!betResponse.ok || !betData || !betData.success) {
                slotResultDisplay.innerHTML = "L·ªói khi ƒë·∫∑t c∆∞·ª£c!";
                showResultModal("API l·ªói", betData && betData.error ? betData.error : betText, "‚ö†Ô∏è");
                await refreshBalance();
                gameLocked = false;
                spinButton.disabled = false;
                return;
            }
            await refreshBalance();

            const finalResults = [];
            let spinPromises = [];

            populateReels(); // ƒê·∫£m b·∫£o c√°c reel c√≥ ƒë·ªß bi·ªÉu t∆∞·ª£ng ƒë·ªÉ quay m∆∞·ª£t

            reels.forEach((reel, index) => {
                const symbolList = reel.querySelector('.symbol-list');
                const targetSymbolIndex = Math.floor(Math.random() * symbols.length);
                const targetSymbol = symbols[targetSymbolIndex];
                finalResults.push(targetSymbol);

                // T√≠nh to√°n v·ªã tr√≠ d·ª´ng th·ª±c t·∫ø c·ªßa bi·ªÉu t∆∞·ª£ng trong danh s√°ch l·∫∑p l·∫°i
                // Ch√∫ng ta mu·ªën bi·ªÉu t∆∞·ª£ng cu·ªëi c√πng hi·ªÉn th·ªã n·∫±m ·ªü gi·ªØa khung nh√¨n
                // ƒê·ªÉ ƒë·∫£m b·∫£o quay qua v√†i v√≤ng, ta th√™m s·ªë v√≤ng quay c·ªë ƒë·ªãnh
                const numSymbolsInList = symbols.length * 3; // V√¨ ta ƒë√£ l·∫∑p l·∫°i 3 l·∫ßn trong populateReels
                const baseSpinCycles = 2; // S·ªë v√≤ng quay c·ªë ƒë·ªãnh
                
                // V·ªã tr√≠ c·ªßa bi·ªÉu t∆∞·ª£ng m·ª•c ti√™u trong m·ªôt chu k·ª≥
                const positionInCycle = targetSymbolIndex;
                
                // T·ªïng s·ªë symbol s·∫Ω l∆∞·ªõt qua ƒë·ªÉ d·ª´ng ·ªü v·ªã tr√≠ mong mu·ªën
                // C·ªông th√™m 1 ƒë·ªÉ ƒë·∫£m b·∫£o symbol m·ª•c ti√™u n·∫±m ·ªü gi·ªØa sau khi animation reset
                const totalSymbolsToPass = (baseSpinCycles * symbols.length) + positionInCycle;

                const finalTransformY = -(totalSymbolsToPass * REEL_HEIGHT);

                // Reset position to a "starting" point that allows continuous spin
                symbolList.style.transition = 'none'; // T·∫Øt transition ƒë·ªÉ reset ngay l·∫≠p t·ª©c
                // ƒê·∫∑t v·ªã tr√≠ ban ƒë·∫ßu gi·∫£ ƒë·ªãnh ·ªü cu·ªëi list ƒë·ªÉ khi animation ch·∫°y n√≥ s·∫Ω cu·ªôn l√™n
                // ƒê√¢y l√† ƒëi·ªÉm quan tr·ªçng ƒë·ªÉ t·∫°o c·∫£m gi√°c "quay v√¥ t·∫≠n" r·ªìi d·ª´ng
                symbolList.style.transform = `translateY(${REEL_HEIGHT}px)`; // ƒê·∫∑t l√πi l·∫°i m·ªôt ch√∫t ƒë·ªÉ animation b·∫Øt ƒë·∫ßu t·ª´ ph√≠a tr√™n

                setTimeout(() => {
                    reel.classList.add('spinning'); // B·∫Øt ƒë·∫ßu animation quay nhanh
                    // ƒê·∫∑t v·ªã tr√≠ m·ª•c ti√™u cho animation, n√≥ s·∫Ω t·ª± ƒë·ªông ch·∫°y l√™n
                    symbolList.style.transition = `transform ${SPIN_DURATION_BASE + (index * SPIN_DURATION_OFFSET)}ms cubic-bezier(0.25, 0.46, 0.45, 0.94)`; // Ease-out cho d·ª´ng
                    // Di chuy·ªÉn ƒë·∫øn m·ªôt v·ªã tr√≠ r·∫•t xa ƒë·ªÉ animation ch·∫°y li√™n t·ª•c
                    symbolList.style.transform = `translateY(-${(symbols.length * 3 * REEL_HEIGHT) + REEL_HEIGHT * 5}px)`; // Di chuy·ªÉn r·∫•t xa
                }, 50); // Ch·ªù m·ªôt ch√∫t ƒë·ªÉ reset position

                spinPromises.push(new Promise(resolve => {
                    setTimeout(() => {
                        reel.classList.remove('spinning'); // D·ª´ng animation quay nhanh
                        symbolList.style.transition = `transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)`; // Transition cho d·ª´ng
                        // Quay l·∫°i v·ªã tr√≠ ban ƒë·∫ßu (0px) r·ªìi sau ƒë√≥ t√≠nh to√°n ƒë·ªÉ hi·ªÉn th·ªã ƒë√∫ng k√Ω hi·ªáu
                        // C√°ch t·ªët nh·∫•t l√† sau khi d·ª´ng animation, ta s·∫Ω ngay l·∫≠p t·ª©c ƒë·∫∑t l·∫°i DOM ƒë·ªÉ hi·ªÉn th·ªã ƒë√∫ng k·∫øt qu·∫£
                        
                        // ƒê·ªÉ ƒë·∫£m b·∫£o d·ª´ng ƒë√∫ng, ch√∫ng ta s·∫Ω l√†m th·∫ø n√†y:
                        // 1. D·ª´ng animation
                        // 2. Clear symbolList v√† ch·ªâ th√™m 1 symbol duy nh·∫•t l√† finalResult
                        symbolList.innerHTML = '';
                        const resultSpan = document.createElement('span');
                        resultSpan.textContent = targetSymbol;
                        symbolList.appendChild(resultSpan);
                        symbolList.style.transform = `translateY(0)`; // ƒê·∫∑t v·ªÅ 0 ƒë·ªÉ symbol hi·ªÉn th·ªã ch√≠nh gi·ªØa reel

                        resolve();
                    }, SPIN_DURATION_BASE + (index * SPIN_DURATION_OFFSET));
                }));
            });

            await Promise.all(spinPromises);

            checkSlotResult(finalResults);

        } catch (e) {
            slotResultDisplay.innerHTML = "L·ªói!";
            showResultModal("L·ªói m·∫°ng/API", String(e), "‚ö†Ô∏è");
            await refreshBalance();
            reels.forEach(reel => {
                reel.classList.remove('spinning');
                reel.querySelector('.symbol-list').style.transform = `translateY(0px)`;
            });
            gameLocked = false;
            spinButton.disabled = false;
        }
    }

    async function checkSlotResult(resultSymbols) {
        let winnings = 0;
        let matchingSymbolsCount = 0;

        const s1 = resultSymbols[0];
        const s2 = resultSymbols[1];
        const s3 = resultSymbols[2];

        // Check for 3 matching symbols
        if (s1 === s2 && s2 === s3) {
            matchingSymbolsCount = 3;
        }
        // Check for 2 matching symbols (either first two, or last two)
        else if (s1 === s2 || s2 === s3) {
            matchingSymbolsCount = 2;
        }
        // If no 2 or 3 matches, then it's effectively 1 matching symbol (any symbol on the payline)
        else {
            matchingSymbolsCount = 1;
        }


        // Calculate winnings based on bet and matching symbols
        switch (currentBetAmount) {
            case 2:
                if (matchingSymbolsCount === 1) winnings = 1;
                else if (matchingSymbolsCount === 2) winnings = 2;
                else if (matchingSymbolsCount === 3) winnings = 5;
                break;
            case 6:
                if (matchingSymbolsCount === 1) winnings = 3;
                else if (matchingSymbolsCount === 2) winnings = 6;
                else if (matchingSymbolsCount === 3) winnings = 15;
                break;
            case 10:
                if (matchingSymbolsCount === 1) winnings = 5;
                else if (matchingSymbolsCount === 2) winnings = 10;
                else if (matchingSymbolsCount === 3) winnings = 20;
                break;
            case 15:
                if (matchingSymbolsCount === 1) winnings = 7;
                else if (matchingSymbolsCount === 2) winnings = 15;
                else if (matchingSymbolsCount === 3) winnings = 25;
                break;
            case 20:
                if (matchingSymbolsCount === 1) winnings = 10;
                else if (matchingSymbolsCount === 2) winnings = 20;
                else if (matchingSymbolsCount === 3) winnings = 35;
                break;
            default:
                winnings = 0;
        }

        try {
            let response = await fetch(`${BACKEND_URL}/play/win`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ wallet: userAddress, winAmount: winnings })
            });
            let text = await response.text();
            let data = null;
            try { data = JSON.parse(text); } catch(e){}
            if (!response.ok || !data || !data.success) {
                showResultModal("API l·ªói", data && data.error ? data.error : text, "‚ö†Ô∏è");
            } else {
                if (winnings > 0) {
                    slotResultDisplay.innerHTML = `Th·∫Øng: ${winnings.toLocaleString()} Xu!`;
                    showResultModal("Ch√∫c m·ª´ng!", `B·∫°n th·∫Øng ${winnings.toLocaleString()} xu!`, "üéâ");
                } else {
                    slotResultDisplay.innerHTML = `B·∫°n ƒë√£ thua ${currentBetAmount.toLocaleString()} Xu.`;
                    showResultModal("Thua r·ªìi!", `B·∫°n ƒë√£ thua ${currentBetAmount.toLocaleString()} xu.`, "üò¢");
                }
            }
        } catch (e) {
            showResultModal("API l·ªói", String(e), "‚ö†Ô∏è");
        }
        await refreshBalance();
        gameLocked = false;
        spinButton.disabled = false;
    }

    betAmountBtns.forEach(btn => btn.onclick = () => {
        if (gameLocked) return;
        betAmountBtns.forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        currentBetAmount = parseInt(btn.dataset.amount);
        updateBetInfo();
    });

    spinButton.onclick = spinReels;

    playAgainBtn.onclick = () => {
        initializeGame();
    };
    modalOverlay.onclick = hideResultModal;

    connectWalletBtn.onclick = connectWallet;
    async function connectWallet() {
        if (typeof window.ethereum === 'undefined') {
            alert("B·∫°n c·∫ßn c√†i MetaMask!");
            return;
        }
        try {
            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            if (accounts.length > 0) {
                userAddress = accounts[0].toLowerCase();
                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner(userAddress);
                updateWalletUI();
                await refreshBalance();
                setControlsBasedOnWallet();
                initializeGame();
            }
        } catch (e) {
            alert("L·ªói khi k·∫øt n·ªëi v√≠: " + (e.message || e));
        }
    }

    document.addEventListener('DOMContentLoaded', async () => {
        if (window.ethereum) {
            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
            if (accounts.length > 0) {
                userAddress = accounts[0].toLowerCase();
                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner(userAddress);
                updateWalletUI();
                await refreshBalance();
            }
        }
        setControlsBasedOnWallet();
        initializeGame();
    });
    window.addEventListener('focus', () => {
        refreshBalance();
    });

    if(window.ethereum){
        window.ethereum.on('accountsChanged', async (accounts) => {
            if(accounts.length > 0){
                userAddress = accounts[0].toLowerCase();
                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner(userAddress);
                updateWalletUI();
                await refreshBalance();
            } else {
                userAddress = null;
                updateWalletUI();
                currentBalance = 0;
                updateWalletDisplay();
            }
            setControlsBasedOnWallet();
        });
    }
    </script>
</body>
</html>
